# Import from the environment the variable INDOCKER.
# Then, compare it with "1" if it doesn't match stop with
# a message error.
# INDOCKER should be set to "1" to signal that we are running Tup
# in the correct docker so we can be sure that all the commands and
# scripts here will be run using the tools in the docker container
import INDOCKER
ifneq (1,$(INDOCKER))
error Stop! You must be in the container for developing.
endif

# Preprocess the first input file (%1f) with Jinja2 and output
# the resulting file into %1o.
#
# The preprocessing takes second input file that should be a YAML
# file with the configuration for the template processing.
#
# We assume that such YAML file is in next to the input file (%1f)
# but wit the additional extension .yml (%1f.yml)
#
# Because such extra input file is not going to be present in the initial
# input list, Tup will complain if the extra input file (%1f.yml) was generated
# by another Tup-rule because Tup will not be able to properly order the rules
# that *generates* the %1f.yml file and the rules that *requieres* such
# file (like the rules that use the !j2 macro below).
# To fix this, this macro adds %1f.yml in the order-only input file so Tup
# can know that this Tup-rule *depends* on that file too besides the input %1f
!j2 = |> ^ j2 %f^ j2 --customize scripts/j2helpers.py %1f %2f > %o |>  | ^scripts/__pycache__/* ^scripts/x/__pycache__/* ^dbg/

!extract-front = |> ^ front %f^ ./scripts/front.py %1f %1o %2o %3o %4o site.yaml |>  | ^scripts/__pycache__/* ^scripts/x/__pycache__/* ^dbg/


# Optimize the size of the PNG images
!minify-png = |> ^ minify %f^ optipng -o7 --strip all -quiet -out %1o %1f |>  | ^scripts/__pycache__/* ^scripts/x/__pycache__/* ^dbg/

# Compilers
!compile-scss = |> ^ compile %f^ sass --load-path=.  %1f %1o |>  | ^scripts/__pycache__/* ^scripts/x/__pycache__/* ^dbg/
!compile-md = |> ^ compile %B^ ./scripts/html.sh %1f %2f %1o |>   | ^scripts/__pycache__/* ^scripts/x/__pycache__/* ^dbg/
!combine-ymls = |> ^ combine %B^ ./scripts/combine-ymls.py %1o %f |>   | ^scripts/__pycache__/* ^scripts/x/__pycache__/* ^dbg/
!make-feed = |> ^ feed %B^ ./scripts/make-feed.py %1o %2o %f |>   | ^scripts/__pycache__/* ^scripts/x/__pycache__/* ^dbg/

# Minifiers
!minify-css = |> ^ minify %f^ cleancss -O1 --source-map -o %1o %1f |>  | ^scripts/__pycache__/* ^scripts/x/__pycache__/* ^dbg/
!minify-js = |> ^ minify %f^ uglifyjs --source-map --compress --mangle -o %1o -- %1f |>  | ^scripts/__pycache__/* ^scripts/x/__pycache__/* ^dbg/

!add-refs = |> ^ ref %B^ ./scripts/add-refs.py %f %o  |>  | ^scripts/__pycache__/* ^scripts/x/__pycache__/* ^dbg/

!convert-font = |> ^ convert %f^ ./scripts/convert-font.py %1f %1o |>  | ^scripts/__pycache__/* ^scripts/x/__pycache__/* ^dbg/

!cp = |> ^ cp %f^ cp %f %o |>

# Posts pipeline
# --------------

{% for f in glob('posts/**/*.md') -%}

{# (!extract-front) Extract the front matter (YAML) of each post and generate:
   - the post's content with a layout set
   - the post's content without a layout set
   - the post's excerpt
   - the front matter metadata in a yml file #}
: {{f}} |> !extract-front |> {{ f('out/posts/front/{:n.md, .no-layout.md, .excerpt.md, .yml}') }}


{# (!j2) Process each Jinja template Markdown file reading the YAML configuration
   and generate the "final" Markdown file. The same goes for the content
   without layout and the excerpt. #}
: {{ f('out/posts/front/{:n.md, .yml}') }} |> !j2 |> {{ f('out/posts/md/{:b}') }}
: {{ f('out/posts/front/{:n.excerpt.md, .yml}') }} |> !j2 |> {{ f('out/posts/md/{:n.excerpt.md}') }}
: {{ f('out/posts/front/{:n.no-layout.md, .yml}') }} |> !j2 |> {{ f('out/posts/md/{:n.no-layout.md}') }}


{# (!compile-md) Compile each Markdown into a HTML
   using the yml to customize it further. #}
: {{ f('out/posts/md/{:b}') }} {{ f('out/posts/front/{:n.yml}') }} \
    |> !compile-md                                                 \
    |> {{ f('out/site/articles/{:D}.html') }}

: {{ f('out/posts/md/{:n.no-layout.md}') }} {{ f('out/posts/front/{:n.yml}') }} \
    |> !compile-md                                                 \
    |> {{ f('out/posts/html/{:n.html}') }}


{# (!add-refs) Create an augmented metadata file (yaml) from the post's
   yaml adding file references. #}
: {{ f('out/posts/front/{:n.yml}') }}                               \
    |> !add-refs                                                    \
        excerpt-j2 {{ f('out/posts/front/{:n.excerpt.md}') }} \
        content-html {{ f('out/posts/html/{:n.html}') }}       \
    |> {{ f('out/posts/meta/{:n.yml}') }}
# ---
{% endfor %}

#
# End of the Posts pipeline ------

# Pages pipeline
# --------------
#  - extract the front of each page (and create pages' .yml)
#  - take each page's .yml and all the posts' .yml and create a single "combined" .yml
#  - run j2 over each page with the "combined" .yml and obtain a .md
#    make this step dependant of the excerpt files created by the Post pipeline
#    because it is likely that the index page will include some of them.
#  - compile the markdown and obtain the .html
{% for f in glob('pages/**/*.md', rel='pages/') -%}
: {{ f('pages/{:f}') }}                                     \
    |> !extract-front                                       \
    |> {{ f('out/pages/front/{:f.md, .no-layout.md, .excerpt.md, .yml}') }}

: {{ f('out/pages/front/{:f.yml}') }} {{ glob('out/posts/meta/*.yml') | join(' ') }}    \
    |> !combine-ymls                                        \
    |> {{ f('out/pages/front/{:f.comb.yml}') }}

: {{ f('out/pages/front/{:f.md, .comb.yml}') }} | {{ glob('out/posts/front/*.excerpt.md') | join(' ') }}    \
    |> !j2                                                  \
    |> {{ f('out/pages/md/{:f}') }}

: {{ f('out/pages/md/{:f}') }} {{ f('out/pages/front/{:f.comb.yml}') }}     \
    |> !compile-md                                          \
    |> {{ f('out/site/{:f.html}') }}
# ---
{% endfor %}
# ---


# Posts' assets pipeline
# -----------------------
{% for f in glob('posts/**/*.sh') -%}
: {{f}} |> !cp|> {{ f('out/site/assets/{:f}', 'posts/') }}
# ---
{% endfor %}

#
# End of the Posts pipeline ------


# Feed generation
# ---------------
: site.yaml {{ glob('out/posts/meta/*.yml') | join(' ') }}      \
    | {{ glob('out/posts/html/*.html') | join(' ') }}     \
    |> !make-feed                                               \
    |> out/site/rss.xml out/site/atom.xml


# PNG pipeline
{% for f in glob('posts/**/*.png') -%}
: {{f}} |> !minify-png |> {{f('out/site/img/{:f}', 'posts/')}}
{% endfor %}

{% for f in glob('z/img/**/*.png') -%}
: {{f}} |> !minify-png |> {{f('out/site/img/{:f}', 'z/img/')}}
{% endfor %}
#
# End of the PNG pipeline ------



# CSS pipeline
# ------------

# Compile SCSS to CSS
: foreach z/css/*.scss |> !compile-scss |> out/z/css/%B.css out/z/css/%B.css.map

# Minify CSS
: foreach out/z/css/*.css |> !minify-css |> out/site/css/%B.min.css out/site/css/%B.min.css.map
: foreach z/css/*.css |> !minify-css |> out/site/css/%B.min.css out/site/css/%B.min.css.map
#
# End of the CSS pipeline ------




# Font pipeline
# -------------
#
# Convert the given fonts (TTF / WOFF) in the latest font format
# for the web: WOFF2.
#
# Input fonts of type WOFF2 are copied as they are.
#
{% for f in glob('z/fonts/**/*.woff') -%}
: {{f}} |> !convert-font |> {{f('out/site/{:f.woff2}', 'z/')}}
{% endfor %}

{% for f in glob('z/fonts/**/*.ttf') -%}
: {{f}} |> !convert-font |> {{f('out/site/{:f.woff2}', 'z/')}}
{% endfor %}

{% for f in glob('z/fonts/**/*.woff2') -%}
: {{f}} |> !cp |> {{f('out/site/{:f}', 'z/')}}
{% endfor %}
#
# End of the Font pipeline ------


# JS pipeline
# -----------
#
# Minify the JS files
#
# The JS files of the MathJax lib require that the minified files be
# called as if they weren't minified. This is because MathJax loads
# the files in background and it does not know that we changed their names
{% for f in glob('z/js/**/*.js') -%}
{% if "MathJax" in f %}
: {{f}} |> !minify-js |> {{f('out/site/{:f.js, .js.map}', 'z/')}}
{% else %}
: {{f}} |> !minify-js |> {{f('out/site/{:f.min.js, .min.js.map}', 'z/')}}
{% endif %}
{% endfor %}
#
# End of the JS pipeline ------


# TUP cheatsheet
# ===============
#
# %f represents the input file name;
# %o the output file name;
# %B the basename of the input (no extension, no directory)
# %g the matched glob of a foreach



